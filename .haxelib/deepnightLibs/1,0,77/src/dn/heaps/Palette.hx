package dn.heaps;

class Palette {
	var colors : Array<Col> = [];
	var _cachedClosests : Map<Int,Col> = new Map();

	public var length(get,never) : Int; inline function get_length() return colors.length;

	public var black(get,never): Col;		inline function get_black() return getClosest("#0");
	public var darkGray(get,never): Col;	inline function get_darkGray() return getClosest("#5");
	public var midGray(get,never): Col;		inline function get_midGray() return getClosest("#8");
	public var lightGray(get,never): Col;	inline function get_lightGray() return getClosest("#c");
	public var white(get,never): Col;		inline function get_white() return getClosest("#f");

	public var yellow(get,never): Col;		inline function get_yellow() return getClosest("#ff0");
	public var lightRed(get,never): Col;	inline function get_lightRed() return getClosest("#f00");
	public var lightGreen(get,never): Col;	inline function get_lightGreen() return getClosest("#0f0");
	public var lightBlue(get,never): Col;	inline function get_lightBlue() return getClosest("#00f");
	public var lightOrange(get,never): Col;	inline function get_lightOrange() return getClosest("#fb0");
	public var lightCyan(get,never): Col;	inline function get_lightCyan() return getClosest("#0ff");
	public var lightPink(get,never): Col;	inline function get_lightPink() return getClosest("#f0f");

	public var darkRed(get,never): Col;		inline function get_darkRed() return getClosest("#800");
	public var darkGreen(get,never): Col;	inline function get_darkGreen() return getClosest("#080");
	public var darkBlue(get,never): Col;	inline function get_darkBlue() return getClosest("#008");
	public var darkOrange(get,never): Col;	inline function get_darkOrange() return getClosest("#a80");
	public var darkCyan(get,never): Col;	inline function get_darkCyan() return getClosest("#088");
	public var darkPink(get,never): Col;	inline function get_darkPink() return getClosest("#808");

	public inline function new() {}

	public inline function iterator() return colors.iterator();

	/** Read palette from an horizontal or vertical palette image, such as the ones generated by LoSpec.com **/
	public static function fromPaletteImage(pixels:hxd.Pixels, colorSize=1, vertical=false) : Palette {
		var pal = new Palette();
		var x = 0;
		while( x<pixels.width ) {
			var c : Col = vertical ? pixels.getPixel(0,x) : pixels.getPixel(x,0);
			pal.colors.push(c.withoutAlpha());
			x+=colorSize;
		}
		return pal;
	}

	/** Read all image pixels and return all unique colors **/
	public static function fromImagePixels(pixels:hxd.Pixels) : Palette {
		var pal = new Palette();
		var dones = new Map();
		var c : Col = 0;
		for(y in 0...pixels.height)
		for(x in 0...pixels.width) {
			c = Col.fromInt( pixels.getPixel(x,y) ).withoutAlpha();
			if( !dones.exists(c) ) {
				dones.set(c,true);
				pal.addColor(c);
			}
		}
		return pal;
	}

	/** Read palette from an Aseprite image **/
	#if heaps_aseprite
	public static function fromAseprite(ase:aseprite.Aseprite) : Palette {
		var pal = new Palette();
		for(i in ase.palette.firstColorIndex...ase.palette.lastColorIndex+1) {
			var c : Col = ase.palette.entries.get(i);
			pal.addColor( c.withoutAlpha() );
		}
		return pal;
	}
	#end

	var cacheIsEmpty = true;
	inline function clearCache() {
		if( !cacheIsEmpty ) {
			cacheIsEmpty = true;
			_cachedClosests = new Map();
		}
	}

	public inline function addColor(c:Col) {
		colors.push(c);
		clearCache();
	}

	public inline function removeColor(c:Col) {
		colors.remove(c);
		clearCache();
	}

	public inline function empty() {
		colors = [];
		clearCache();
	}

	@:keep
	public inline function toString() {
		return 'Palette(${colors.length}): ${colors.map(c->c.toString()).join(",")}';
	}

	/** Render current palette colors **/
	public function render(colSizePx=8, ?parent:h2d.Object) : h2d.Flow {
		var f = new h2d.Flow(parent);
		f.layout = Horizontal;
		f.verticalAlign = Middle;

		inline function _renderColor(c:Col, f:h2d.Flow) {
			var bmp = new h2d.Bitmap( h2d.Tile.fromColor(c), f );
			bmp.setScale(colSizePx);
		}

		for( c in colors )
			_renderColor(c, f);
		return f;
	}

	/** Render palette preset colors **/
	public function renderPresets(colSizePx=8, ?parent:h2d.Object) : h2d.Flow {
		var f = new h2d.Flow(parent);
		f.layout = Horizontal;
		f.verticalAlign = Top;

		inline function _renderColorPair(c1:Col, c2:Col, f:h2d.Flow) {
			var pair = new h2d.Flow(f);
			pair.layout = Vertical;
			var bmp = new h2d.Bitmap( h2d.Tile.fromColor(c1), pair );
			bmp.setScale(colSizePx);
			var bmp = new h2d.Bitmap( h2d.Tile.fromColor(c2), pair );
			bmp.setScale(colSizePx);
		}
		_renderColorPair("#f", white, f);
		_renderColorPair("#c", lightGray, f);
		_renderColorPair("#9", midGray, f);
		_renderColorPair("#5", darkGray, f);
		_renderColorPair("#0", black, f);

		_renderColorPair("#f00", lightRed, f);
		_renderColorPair("#0f0", lightGreen, f);
		_renderColorPair("#00f", lightBlue, f);
		_renderColorPair("#0ff", lightCyan, f);
		_renderColorPair("#f0f", lightPink, f);
		_renderColorPair("#fa0", lightOrange, f);
		_renderColorPair("#ff0", yellow, f);

		_renderColorPair("#800", darkRed, f);
		_renderColorPair("#080", darkGreen, f);
		_renderColorPair("#008", darkBlue, f);
		_renderColorPair("#088", darkCyan, f);
		_renderColorPair("#808", darkPink, f);
		_renderColorPair("#a80", darkOrange, f);

		return f;
	}


	public inline function getClosest(target:Col, useLab=false) : Col {
		if( _cachedClosests.exists(target) )
			return _cachedClosests.get(target);
		else {
			// Search closest palette entry
			var best : Col = 0x0;
			var bestDist = 99.;
			var dist = 0.;
			for(c in colors) {
				dist = useLab ? target.getDistanceLab(c) : target.getDistanceRgb(c);
				if( dist<bestDist ) {
					bestDist = dist;
					best = c;
					if( dist==0 )
						break;
				}
			}
			cacheIsEmpty = false;
			_cachedClosests.set(target, best);
			return best;
		}
	}


}
